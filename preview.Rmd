---
title: "AB programación: Dataset de estudiantes"
output: html_notebook
---

## Explicación del dataset

El dataset ha sido sacado de la pagina kaggle: <https://www.kaggle.com/>. De la sección de datasets, específicamente hemos escogido este dataset: <https://www.kaggle.com/datasets/lainguyn123/student-performance-factors>. Este conjunto de datos ofrece una visión completa de diversos factores que afectan al rendimiento de los estudiantes en los exámenes. Incluye información sobre hábitos de estudio, asistencia, participación de los padres y otros aspectos que influyen en el éxito académico.

# Parte 1: carga y exploración de datos.

```{r}
library(readr)
library(skimr)
library(dplyr)
library(esquisse)
library(reshape2)
library(ggplot2)
library(tidyr)

```

primero importamos el dataset, ademas importamos la librería skimr para la mejor visualización de los datos

```{r message=FALSE, warning=TRUE, paged.print=TRUE, show_col_types=}
st <- read_csv("estudiantes.csv", show_col_types = FALSE)
head(st,10, show_col_types = FALSE)
```

Tras un primer vistazo podemos observar que tenemos 20 columnas y tenemos tanto valores numéricos como no numéricos. Ademas sospechamos que hay bastantes valores categóricos. Vamos a analizarlo mas a fondo.

separamos las columnas numéricas de las no numéricas para mejor observación de los datos

```{r}
numeric_columns <- sapply(st, is.numeric)
```

```{r}
# Imprimir los valores únicos de todas las columnas no numéricas
lapply(st[!numeric_columns], unique)

```

Aquí podemos ver que todos las columnas no numéricas son categóricas. esto lo tendremos en cuenta para el análisis y la limpieza mas adelante

Ahora buscamos los valores nulos dentro de las columnas

Usamos skim mejor que `summary()` porque da mas información y presentada de forma mas limpia

```{r}
skim(st[!numeric_columns])
```

Se observa que tenemos valores nulos en 3 columnas: `Teacher_Quality`, `Parental_Educational_Level` y `Distance_From_Home` Mas tarde en la limpieza de datos veremos que hacer con ellos.

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
skim(st[numeric_columns])
```

En los datos numéricos al contrario que pasaba en los no numéricos no tenemos ningún valor nulo.

# Parte 2: Limpieza de datos

vemos que tenemos valores nulos en 3 columnas:`Parental_Education_Level`, `Teacher_Quality`, `Distance_from_Home`\
como las 3 columnas son categóricas vamos a usar la moda en las 3 para poner el valor que mas se repite. como en r no existe una función que obtenga la moda directamente la creamos nosotros mismos.

```{r}
getmode <- function(v) {
   uniqv <- unique(v)                     
   uniqv[which.max(tabulate(match(v, uniqv)))]
}
```

```{r}
st <- st %>%
  mutate(
    Teacher_Quality = ifelse(is.na(Teacher_Quality), getmode(Teacher_Quality), Teacher_Quality), #si es NA (TRUE) salta `getmode(columna)`,si es False no cambia nada
    Parental_Education_Level = ifelse(is.na(Parental_Education_Level), getmode(Parental_Education_Level), Parental_Education_Level),
    Distance_from_Home = ifelse(is.na(Distance_from_Home), getmode(Distance_from_Home), Distance_from_Home)
  )

```

el `%\>%` esto es el `pipe`, que esta tomando el df `st`y lo paso como entrada a la siguiente función `mutate()`en este caso. Gracias esto nos evitamos escribir mutate para cada columna, permitiendo "fluir" a la función.

Comprobamos que no hay valores nulos.

```{r}
print(colSums(is.na(st)))
```

No hay valores nulos, lo que nos indica que ha funcionado

## Conversión de valores categóricos en factores de R, gracias a esto conseguimos lo siguiente

-   Los factores permiten a R entender que son datos categóricos y no simples textos\
-   facilita el análisis estadístico y creación de modelos.\
-   Permite establecer ordenes específicos entre categorías si es necesario\
-   Optimiza el uso de memoria de R

Convertimos en factores los categóricos y añadimos orden en algunos de ellos ya que tiene relevancia el orden (low\<medium\<high)

```{r}
st <- st %>%
  mutate(
    Parental_Involvement = factor(Parental_Involvement,
                                levels = c("Low", "Medium", "High"),
                                ordered = TRUE),
    Access_to_Resources = factor(Access_to_Resources,
                               levels = c("Low", "Medium", "High"),
                               ordered = TRUE),
    Extracurricular_Activities = factor(Extracurricular_Activities,
                                      levels = c("No", "Yes")),  
    Motivation_Level = factor(Motivation_Level,
                            levels = c("Low", "Medium", "High"),
                            ordered = TRUE),
    Internet_Access = factor(Internet_Access,
                           levels = c("No", "Yes")),  
    Family_Income = factor(Family_Income,
                         levels = c("Low", "Medium", "High"),
                         ordered = TRUE),
    Teacher_Quality = factor(Teacher_Quality,
                           levels = c("Low", "Medium", "High"),
                           ordered = TRUE),
    School_Type = factor(School_Type),  
    Peer_Influence = factor(Peer_Influence,
                          levels = c("Negative", "Neutral", "Positive"),
                          ordered = TRUE),
    Learning_Disabilities = factor(Learning_Disabilities,
                                 levels = c("No", "Yes")),  
    Parental_Education_Level = factor(Parental_Education_Level,
                                    levels = c("High School", "College", "Postgraduate"),
                                    ordered = TRUE),
    Distance_from_Home = factor(Distance_from_Home,
                              levels = c("Near", "Moderate", "Far"),
                              ordered = TRUE),
    Gender = factor(Gender)  
  )
```

Verificamos que se han convertido en factor.

```{r}
str(st)
```

Devolvemos el csv limpio y trabajaremos con él.

```{r}
# Guardar el data frame limpio en un archivo CSV
write.csv(st, "st_clean.csv", row.names = FALSE)

```

```{r message=FALSE, warning=TRUE, paged.print=TRUE, show_col_types=}
st_clean <- read_csv("st_clean.csv", show_col_types = FALSE)
head(st,10, show_col_types = FALSE)
```

# Análisis de los datos

Primero comprobamos si existe algún tipo de sesgo en los datos que tenemos en genero y recursos.

```{r}
# Variables categóricas que quieres analizar
categorical_vars <- c("Gender", "Family_Income", "School_Type", "Learning_Disabilities")

# Crear gráficos de barras para cada variable categórica
for (var in categorical_vars) {
  p <- ggplot(st_clean, aes_string(x = var)) +
    geom_bar(fill = "skyblue") +
    theme_minimal() +
    labs(title = paste("Distribución de", var), x = var, y = "Frecuencia") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  print(p)
}

```

Sesgo:

-   **Género**: La distribución es equilibrada, lo que sugiere un bajo riesgo de sesgo.

<!-- -->

-   **Ingreso Familiar**: Predominan las clases media y baja, lo que puede influir en los análisis.

-   **Tipo de Escuela**: Mayor representación de escuelas públicas, lo cual podría sesgar los resultados si queremos extrapolarlos hacia grupos donde haya una mayoría de escuela privada.

-   **Discapacidades de Aprendizaje**: Baja representación de estudiantes con discapacidades, lo que podría limitar la representatividad de los análisis en este aspecto.

Podríamos concluir que es un análisis que se podría extrapolar hacia el conjunto mayoritario de la población, es decir, gente de clase media sin `learning_disabilities` y que van a la escuela pública sin tener en cuenta el género.

```{r}
# Cargar paquetes necesarios
library(ggplot2)
library(reshape2)

# Calcular la matriz de correlación (usando solo variables numéricas)
cor_matrix <- cor(st_clean[, sapply(st_clean, is.numeric)], use = "complete.obs")

# Convertir la matriz de correlación en un formato largo para ggplot2
melted_cor_matrix <- melt(cor_matrix)

# Crear el heatmap con los números visibles en los cuadrados
ggplot(data = melted_cor_matrix, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2)), color = "black", size = 3) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), space = "Lab",
                       name = "Correlación") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 10, hjust = 1)) +
  coord_fixed() +
  labs(title = "Mapa de Correlación de Variables con Números Visible")

```

En este mapa de calor Podemos observar en las variables numéricas cuales son las que tienen mas peso con la nota del examen. que en este caso podemos ver que son `Attendance` y `Hours_Studied`.

### Graficos de todo tipo

### Generales

```{r}
# Crear histograma
ggplot(st_clean, aes(x = Exam_Score)) +
  geom_histogram(binwidth = 2, fill = "skyblue", color = "black") +
  theme_minimal() +
  labs(title = "Histograma de Distribución de Exam_Score",
       x = "nota del Examen",
       y = "Frecuencia")
```

```{r}
# Calcular la mediana y la media
mediana_exam_score <- median(st_clean$Exam_Score, na.rm = TRUE)
media_exam_score <- mean(st_clean$Exam_Score, na.rm = TRUE)

# Imprimir los resultados
cat("Mediana de Exam_Score:", mediana_exam_score, "\n")
cat("Media de Exam_Score:", media_exam_score, "\n")

```

Podemos ver la distribución de notas de los estudiantes que se concentra entre el 60 y el 70. Ademas podemos decir que es un histograma casi simétrico, la media y la mediana están muy cerca una de otra.

```{r}
# Crear boxplot
ggplot(st_clean, aes(x = Gender, y = Exam_Score, fill = Gender)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Exam_Score por Gender",
       x = "Género",
       y = "Puntaje del Examen") +
  scale_fill_brewer(palette = "Pastel1")
```

-   la mediana parece similar en ambos géneros.

-   Las cajas que son el rango intercuartilico (Del primer al tercer cuartil), que muestra la dispersión central de los datos. Ambos géneros están igual distribuidos.

-   Rango, los bigotes muestran la variabilidad fuera de los cuartiles. Ambos géneros tienen un rango similar.

-   Valores atípicos: Hay valores atípicos en ambos géneros, lo cual indica que hay alumnos con notas o mas altas o mas bajas que la mayoría.

## Buscamos si el nivel de motivación influye en las variables con correlaciones mas elevadas.

estas son:

-   `Hours_Studied`

-   `Attendance`

```{r}
ggplot(st_clean, aes(x = Sleep_Hours, y = Exam_Score, color = Motivation_Level)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  labs(title = "Diagrama de Dispersión de Sleep_Hours vs Exam_Score",
       x = "Horas de Sueño",
       y = "Puntaje del Examen",
       color = "Nivel de Motivación") +
  scale_color_brewer(palette = "Set1")
```

no hay nada relevante que podamos sacar de aquí. podemos analizar los valores atípicos. la motivación alta no asegura una nota elevada y tampoco dormir poco te asegura una nota alta.

Pero sin embargo si comparamos con un gráfico mas adecuado podemos observar que si que tiene que ver.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear gráfico de densidad para diferentes niveles de motivación
ggplot(st_clean, aes(x = Exam_Score, fill = Motivation_Level)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Exam_Score por Nivel de Motivación",
       x = "Puntaje del Examen",
       y = "Densidad",
       fill = "Nivel de Motivación") +
  scale_fill_manual(values = c("High" = "lightblue", "Medium" = "lightgreen", "Low" = "lightpink"))


```

si observamos el gráfico podemos decir que la motivación bajo tiene notas inferiores en comparación con las notas altas.

```{r}
# Crear gráfico de densidad para diferentes niveles de motivación
ggplot(st_clean, aes(x = Attendance, fill = Motivation_Level)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Asistencia por Nivel de Motivación",
       x = "Attendance",
       y = "Densidad",
       fill = "Nivel de Motivación") +
  scale_fill_manual(values = c("High" = "lightblue", "Medium" = "lightgreen", "Low" = "lightpink"))
```

```{r}
# Crear boxplot de Attendance por Motivation_Level
ggplot(st_clean, aes(x = Motivation_Level, y = Attendance, fill = Motivation_Level)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Attendance por Nivel de Motivación",
       x = "Nivel de Motivación",
       y = "Horas de Asistencia") +
  scale_fill_manual(values = c("High" = "lightblue", "Medium" = "lightgreen", "Low" = "lightpink"))

```

No hay grandes diferencias entre los niveles de motivación y la asistencia a clase. se puede ver que la mediana de la motivación alta es menor, esta tiene los picos mas altos en dos puntos, asistencia en torno al 70 y al 95. sin embargo la motivación media y baja son mas estables en la asistencia.

Ahora vamos a analizar las horas estudiadas

```{r}
ggplot(st_clean, aes(x = Hours_Studied, y = Exam_Score, color = Motivation_Level)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  labs(title = "Diagrama de Dispersión de horas de estudio vs Exam_Score",
       x = "Horas de estudio",
       y = "notas del Examen",
       color = "Nivel de Motivación") +
  scale_color_brewer(palette = "Set1")
```

podemos ver que a medida que aumentan las horas de estudio, aumentan la nota. Podríamos decir que los valores anómalos en la nota se centran en los valores medios y no en los extremos de horas estudiadas.

```{r}
ggplot(st_clean, aes(x = Hours_Studied, fill = Motivation_Level)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Asistencia por Nivel de Motivación",
       x = "horas estudiadas",
       y = "Densidad",
       fill = "Nivel de Motivación") +
  scale_fill_manual(values = c("High" = "lightblue", "Medium" = "lightgreen", "Low" = "lightpink"))
```

No hay diferencias muy elevadas en las horas estudiadas según el nivel de motivación, pero podemos observar que los de baja motivación concentran mas sus horas de estudio por debajo de las 20 y los de alta motivación concentran sus horas de estudios en mas de 20. sin embargo los de motivación media dispersan mas las horas estudiadas llegando mayor cantidad de horas desplazándose un poco mas a la derecha que las otras dos.

```{r}

# Crear gráfico de densidad de Exam_Score por Teacher_Quality
ggplot(st_clean, aes(x = Exam_Score, fill = Teacher_Quality)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Exam_Score por Nivel de Calidad del Profesorado",
       x = "Puntaje del Examen",
       y = "Densidad",
       fill = "Calidad del Profesorado") +
  scale_fill_brewer(palette = "Set2")


```

Se puede observar que la calidad del profesor parece estar asociada con una tendencia a mejores puntajes en el examen, especialmente para la categoría de calidad alta. Sin embargo, la diferencia entre las curvas de densidad no es muy significativa, por lo que se requeriría un análisis más profundo para confirmar esta relación de manera concluyente.

```{r}
ggplot(st_clean, aes(x = Access_to_Resources, y = Exam_Score, fill = Access_to_Resources)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Exam_Score por Access_to_Resources",
       x = "Acceso a Recursos",
       y = "Puntaje del Examen") +
  scale_fill_brewer(palette = "Set1")
```

Vamos a analizar cuanto influyen las horas de tutoría en el resultado final.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear boxplot de Exam_Score por Tutoring_Sessions
ggplot(st_clean, aes(x = as.factor(Tutoring_Sessions), y = Exam_Score, fill = as.factor(Tutoring_Sessions))) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Exam_Score por Número de Sesiones de Tutoría",
       x = "Número de Sesiones de Tutoría",
       y = "Puntaje del Examen",
       fill = "Sesiones de Tutoría") +
  scale_fill_brewer(palette = "Set3")

```

```{r}
# Crear gráfico de dispersión de Tutoring_Sessions vs Exam_Score
ggplot(st_clean, aes(x = Tutoring_Sessions, y = Exam_Score)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Línea de tendencia
  theme_minimal() +
  labs(title = "Gráfico de Dispersión de Tutoring_Sessions vs Exam_Score",
       x = "Número de Sesiones de Tutoría",
       y = "Puntaje del Examen")

```

Vemos que hay correlación baja, es decir, influye minimamente las horas de tutoría con la nota del examen

```{r}
ggplot(st_clean, aes(x = Hours_Studied, y = Exam_Score)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Línea de tendencia
  theme_minimal() +
  labs(title = "Gráfico de Dispersión de Hours_Studied vs Exam_Score",
       x = "Número de Hours_Studied",
       y = "Puntaje del Examen")
```

```{r}
ggplot(st_clean, aes(x = Attendance, y = Exam_Score)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Línea de tendencia
  theme_minimal() +
  labs(title = "Gráfico de Dispersión de Attendance vs Exam_Score",
       x = "Número de Attendance",
       y = "Puntaje del Examen")
```

Podemos observar en estos dos gráficos de dispersión que la correlación es positiva y mayor que en la anterior, como decía el heatmap.

## Análisis socio-económico

Aquí buscaremos si los ingresos familiares y la influencia tanto externa como paterna tienen influencia relevante en las notas y el nivel de motivación de los alumnos.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear boxplot de Exam_Score por Family_Income
ggplot(st_clean, aes(x = Family_Income, y = Exam_Score, fill = Family_Income)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Exam_Score por Ingreso Familiar",
       x = "Ingreso Familiar",
       y = "Puntaje del Examen") +
  scale_fill_brewer(palette = "Pastel1")

```

```{r}
# Crear gráfico de densidad de Exam_Score por Teacher_Quality
ggplot(st_clean, aes(x = Exam_Score, fill = Family_Income)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Exam_Score por Nivel ingresos familiares",
       x = "Puntaje del Examen",
       y = "Densidad",
       fill = "ingresos familiares") +
  scale_fill_brewer(palette = "Set2")
```

Los ingresos familiares no son un factor determinante para sacar mejores notas pero podemos observar que mayor ingresos familiares da lugar a mejores notas, ahora podriamos ver si la cantidad de horas estudiadas es mayor en gente con ingresos familiares elevados en comparación con ingresos bajo

```{r}
# Cargar paquetes necesarios
library(dplyr)
library(skimr)

# Resumir Hours_Studied por Family_Income usando skim()
st_clean %>%
  group_by(Family_Income) %>%
  skim(Hours_Studied)
```

Observamos que no.

Buscamos si el nivel de motivación aumenta según `"Parental_Involvement"`y `"Peer_Influence"`.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear gráfico de barras apiladas de Motivation_Level por Peer_Influence
ggplot(st_clean, aes(x = Peer_Influence, fill = Motivation_Level)) +
  geom_bar(position = "fill") +
  theme_minimal() +
  labs(title = "Distribución de Motivation_Level según Peer_Influence",
       x = "Influencia de Pares",
       y = "Proporción",
       fill = "Nivel de Motivación") +
  scale_fill_brewer(palette = "Set2")


```

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear gráfico de barras apiladas de Motivation_Level por Parental_Involvement
ggplot(st_clean, aes(x = Parental_Involvement, fill = Motivation_Level)) +
  geom_bar(position = "fill") +
  theme_minimal() +
  labs(title = "Distribución de Motivation_Level según Parental_Involvement",
       x = "Participación de los Padres",
       y = "Proporción",
       fill = "Nivel de Motivación") +
  scale_fill_brewer(palette = "Set2")

```

Estos gráficos sugieren que la tanto la influencia de los pares (`Peer_Influence`) como el interes de los padres (`Parental_Involvement`) no parecen estar fuertemente asociadas con cambios en el nivel de motivación (`Motivation_Level`). Las proporciones de motivación se mantienen bastante consistentes independientemente de si la influencia de los pares es negativa, neutral o positiva.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear gráfico de barras apiladas de Exam_Score por Peer_Influence
ggplot(st_clean, aes(x = Peer_Influence, y = Exam_Score, fill = Peer_Influence)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Exam_Score por Influencia externa",
       x = "Influencia de Pares",
       y = "Puntaje del Examen") +
  scale_fill_brewer(palette = "Pastel2")

# Crear gráfico de barras apiladas de Exam_Score por Parental_Involvement
ggplot(st_clean, aes(x = Parental_Involvement, y = Exam_Score, fill = Parental_Involvement)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Diagrama de Caja de Exam_Score por Participación de los Padres",
       x = "Participación de los Padres",
       y = "Puntaje del Examen") +
  scale_fill_brewer(palette = "Set2")
```

```{r}
ggplot(st_clean, aes(x = Exam_Score, fill = Peer_Influence)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Exam_Score por influencia externa",
       x = "Puntaje del Examen",
       y = "Densidad",
       fill = "influencia externa") +
  scale_fill_brewer(palette = "Set2")

ggplot(st_clean, aes(x = Exam_Score, fill = Parental_Involvement)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Gráfico de Densidad de Exam_Score por influencia paterna",
       x = "Puntaje del Examen",
       y = "Densidad",
       fill = "influencia paterna") +
  scale_fill_brewer(palette = "Set2")
```

vemos que una influencia paterna alta y una influencia externa positiva tiene mejores resultados académicas que el que no.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear gráfico de violín de Exam_Score por School_Type
ggplot(st_clean, aes(x = School_Type, y = Exam_Score, fill = School_Type)) +
  geom_violin(trim = FALSE) +
  theme_minimal() +
  labs(title = "Gráfico de Violín de Exam_Score por Tipo de Escuela",
       x = "Tipo de Escuela",
       y = "Puntaje del Examen") +
  scale_fill_brewer(palette = "Pastel1")

```

Podríamos decir que, en base a este gráfico, **no hay una diferencia significativa en las notas de examen entre los estudiantes de escuelas públicas y privadas**. La forma y la amplitud de las distribuciones son similares, lo que sugiere que, en este contexto, el tipo de escuela no parece influir considerablemente en los resultados de los exámenes.

```{r}
# Cargar ggplot2
library(ggplot2)

# Crear gráfico de violín de Exam_Score por Family_Income y Gender
ggplot(st_clean, aes(x = Family_Income, y = Exam_Score, fill = Gender)) +
  geom_violin(trim = FALSE, position = position_dodge(0.8)) +
  theme_minimal() +
  labs(title = "Gráfico de Violín de Exam_Score por Ingreso Familiar y Género",
       x = "Ingreso Familiar",
       y = "Puntaje del Examen",
       fill = "Género") +
  scale_fill_brewer(palette = "Pastel1")

```
